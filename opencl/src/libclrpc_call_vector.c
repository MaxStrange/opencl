/* libclrpc_call_vector.c
 * This file was auto-generated by gen_ocl_call_vector.pl
 */

/* __ocl_call_vector  */
#if 0
#include "CL/cl.h"

#include "CL/cl_gl.h"


typedef void (*cl_pfn_notify_t)(const char*, const void*, size_t, void*);
typedef void (*cl_pfn_notify2_t)(cl_program , void* );
typedef void (*cl_user_func_t)(void*);

	cl_int clGetPlatformIDs(cl_uint,cl_platform_id*,cl_uint*);

	cl_int clGetPlatformInfo(cl_platform_id,cl_platform_info,size_t,void*,size_t*);

	cl_int clGetDeviceIDs(cl_platform_id,cl_device_type,cl_uint,cl_device_id*,cl_uint*);

	cl_int clGetDeviceInfo(cl_device_id,cl_device_info,size_t,void*,size_t*);

	cl_context clCreateContext(const cl_context_properties*,cl_uint,const cl_device_id*,cl_pfn_notify_t,void*,cl_int*);

	cl_context clCreateContextFromType(const cl_context_properties*,cl_device_type,cl_pfn_notify_t,void*,cl_int*);

	cl_int clRetainContext(cl_context);

	cl_int clReleaseContext(cl_context);

	cl_int clGetContextInfo(cl_context,cl_context_info,size_t,void*,size_t*);

	cl_command_queue clCreateCommandQueue(cl_context,cl_device_id,cl_command_queue_properties,cl_int*);

	cl_int clRetainCommandQueue(cl_command_queue);

	cl_int clReleaseCommandQueue(cl_command_queue);

	cl_int clGetCommandQueueInfo(cl_command_queue,cl_command_queue_info,size_t,void*,size_t*);

	cl_int clSetCommandQueueProperty(cl_command_queue,cl_command_queue_properties,cl_bool,cl_command_queue_properties*);

	cl_mem clCreateBuffer(cl_context,cl_mem_flags,size_t,void*,cl_int*);

    cl_mem clCreateImage(cl_context,cl_mem_flags,const cl_image_format*, const cl_image_desc*,void*,cl_int*);

	cl_int clRetainMemObject(cl_mem);

	cl_int clReleaseMemObject(cl_mem);

	cl_int clGetSupportedImageFormats(cl_context,cl_mem_flags,cl_mem_object_type,cl_uint,cl_image_format*,cl_uint*);

	cl_int clGetMemObjectInfo(cl_mem,cl_mem_info,size_t,void*,size_t*);

	cl_int clGetImageInfo(cl_mem,cl_image_info,size_t,void*,size_t*);

	cl_sampler clCreateSampler(cl_context,cl_bool,cl_addressing_mode,cl_filter_mode,cl_int*);

	cl_int clRetainSampler(cl_sampler);

	cl_int clReleaseSampler(cl_sampler);

	cl_int clGetSamplerInfo(cl_sampler,cl_sampler_info,size_t,void*,size_t*);

	cl_program clCreateProgramWithSource(cl_context,cl_uint,const char**,const size_t*,cl_int*);

	cl_program clCreateProgramWithBinary(cl_context,cl_uint,const cl_device_id*,const size_t*,const unsigned char**,cl_int*,cl_int*);

	cl_int clRetainProgram(cl_program);

	cl_int clReleaseProgram(cl_program);

	cl_int clBuildProgram(cl_program,cl_uint,const cl_device_id*,const char*,cl_pfn_notify2_t,void*);

    cl_int clUnloadPlatformCompiler(cl_platform_id);

	cl_int clGetProgramInfo(cl_program,cl_program_info,size_t,void*,size_t*);

	cl_int clGetProgramBuildInfo(cl_program,cl_device_id,cl_program_build_info,size_t,void*,size_t*);

	cl_kernel clCreateKernel(cl_program,const char*,cl_int*);

	cl_int clCreateKernelsInProgram(cl_program,cl_uint,cl_kernel*,cl_uint*);

	cl_int clRetainKernel(cl_kernel);

	cl_int clReleaseKernel(cl_kernel);

	cl_int clSetKernelArg(cl_kernel,cl_uint,size_t,const void*);

	cl_int clGetKernelInfo(cl_kernel,cl_kernel_info,size_t,void*,size_t*);

	cl_int clGetKernelWorkGroupInfo(cl_kernel,cl_device_id,cl_kernel_work_group_info,size_t,void*,size_t*);

	cl_int clWaitForEvents(cl_uint,const cl_event*);

	cl_int clGetEventInfo(cl_event,cl_event_info,size_t,void*,size_t*);

	cl_int clRetainEvent(cl_event);

	cl_int clReleaseEvent(cl_event);

	cl_int clGetEventProfilingInfo(cl_event,cl_profiling_info,size_t,void*,size_t*);

	cl_int clFlush(cl_command_queue);

	cl_int clFinish(cl_command_queue);

	cl_int clEnqueueReadBuffer(cl_command_queue,cl_mem,cl_bool,size_t,size_t,void*,cl_uint,const cl_event*,cl_event*);

	cl_int clEnqueueWriteBuffer(cl_command_queue,cl_mem,cl_bool,size_t,size_t,const void*,cl_uint,const cl_event*,cl_event*);

	cl_int clEnqueueCopyBuffer(cl_command_queue,cl_mem,cl_mem,size_t,size_t,size_t,cl_uint,const cl_event*,cl_event*);

	cl_int clEnqueueReadImage(cl_command_queue,cl_mem,cl_bool,const size_t*,const size_t*,size_t,size_t,void*,cl_uint,const cl_event*,cl_event*);

	cl_int clEnqueueWriteImage(cl_command_queue,cl_mem,cl_bool,const size_t*,const size_t*,size_t,size_t,const void*,cl_uint,const cl_event*,cl_event*);

	cl_int clEnqueueCopyImage(cl_command_queue,cl_mem,cl_mem,const size_t*,const size_t*,const size_t*,cl_uint,const cl_event*,cl_event*);

	cl_int clEnqueueCopyImageToBuffer(cl_command_queue,cl_mem,cl_mem,const size_t*,const size_t*,size_t,cl_uint,const cl_event*,cl_event*);

	cl_int clEnqueueCopyBufferToImage(cl_command_queue,cl_mem,cl_mem,size_t,const size_t*,const size_t*,cl_uint,const cl_event*,cl_event*);

	void* clEnqueueMapBuffer(cl_command_queue,cl_mem,cl_bool,cl_map_flags,size_t,size_t,cl_uint,const cl_event*,cl_event*,cl_int*);

	void* clEnqueueMapImage(cl_command_queue,cl_mem,cl_bool,cl_map_flags,const size_t*,const size_t*,size_t*,size_t*,cl_uint,const cl_event*,cl_event*,cl_int*);

	cl_int clEnqueueUnmapMemObject(cl_command_queue,cl_mem,void*,cl_uint,const cl_event*,cl_event*);

	cl_int clEnqueueNDRangeKernel(cl_command_queue,cl_kernel,cl_uint,const size_t*,const size_t*,const size_t*,cl_uint,const cl_event*,cl_event*);

	cl_int clEnqueueTask(cl_command_queue,cl_kernel,cl_uint,const cl_event*,cl_event*);

	cl_int clEnqueueNativeKernel(cl_command_queue,cl_user_func_t,void*,size_t,cl_uint,const cl_mem*,const void**,cl_uint,const cl_event*,cl_event*);

	cl_int clEnqueueMarkerWithWaitList(cl_command_queue,cl_uint,const cl_event*,cl_event*);

	cl_int clEnqueueBarrierWithWaitList(cl_command_queue,cl_uint,const cl_event*,cl_event*);

	cl_mem clCreateFromGLBuffer(cl_context,cl_mem_flags,cl_GLuint,int*);

	cl_mem clCreateFromGLTexture(cl_context,cl_mem_flags,cl_GLenum,cl_GLint,cl_GLuint,cl_int*);

	cl_mem clCreateFromGLRenderbuffer(cl_context,cl_mem_flags,cl_GLuint,cl_int*);

	cl_int clGetGLObjectInfo(cl_mem,cl_gl_object_type*,cl_GLuint*);

	cl_int clGetGLTextureInfo(cl_mem,cl_gl_texture_info,size_t,void*,size_t*);

	cl_int clEnqueueAcquireGLObjects(cl_command_queue,cl_uint,const cl_mem*,cl_uint,const cl_event*,cl_event*);

	cl_int clEnqueueReleaseGLObjects(cl_command_queue,cl_uint,const cl_mem*,cl_uint,const cl_event*,cl_event*);



static void* _cvec[] = { \
	clGetPlatformIDs, \
	clGetPlatformInfo, \
	clGetDeviceIDs, \
	clGetDeviceInfo, \
	clCreateContext, \
	clCreateContextFromType, \
	clRetainContext, \
	clReleaseContext, \
	clGetContextInfo, \
	clCreateCommandQueue, \
	clRetainCommandQueue, \
	clReleaseCommandQueue, \
	clGetCommandQueueInfo, \
	clSetCommandQueueProperty, \
	clCreateBuffer, \
	clCreateImage, \
	clRetainMemObject, \
	clReleaseMemObject, \
	clGetSupportedImageFormats, \
	clGetMemObjectInfo, \
	clGetImageInfo, \
	clCreateSampler, \
	clRetainSampler, \
	clReleaseSampler, \
	clGetSamplerInfo, \
	clCreateProgramWithSource, \
	clCreateProgramWithBinary, \
	clRetainProgram, \
	clReleaseProgram, \
	clBuildProgram, \
    clUnloadPlatformCompiler, \
	clGetProgramInfo, \
	clGetProgramBuildInfo, \
	clCreateKernel, \
	clCreateKernelsInProgram, \
	clRetainKernel, \
	clReleaseKernel, \
	clSetKernelArg, \
	clGetKernelInfo, \
	clGetKernelWorkGroupInfo, \
	clWaitForEvents, \
	clGetEventInfo, \
	clRetainEvent, \
	clReleaseEvent, \
	clGetEventProfilingInfo, \
	clFlush, \
	clFinish, \
	clEnqueueReadBuffer, \
	clEnqueueWriteBuffer, \
	clEnqueueCopyBuffer, \
	clEnqueueReadImage, \
	clEnqueueWriteImage, \
	clEnqueueCopyImage, \
	clEnqueueCopyImageToBuffer, \
	clEnqueueCopyBufferToImage, \
	clEnqueueMapBuffer, \
	clEnqueueMapImage, \
	clEnqueueUnmapMemObject, \
	clEnqueueNDRangeKernel, \
	clEnqueueTask, \
	clEnqueueNativeKernel, \
	clEnqueueMarkerWithWaitList, \
	clEnqueueBarrierWithWaitList, \
	clCreateFromGLBuffer, \
	clCreateFromGLTexture, \
	clCreateFromGLRenderbuffer, \
	clGetGLObjectInfo, \
	clGetGLTextureInfo, \
	clEnqueueAcquireGLObjects, \
	clEnqueueReleaseGLObjects, \
	};

void** __ocl_call_vector = (void**)_cvec;
#endif
